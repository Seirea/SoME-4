#!/usr/bin/env python3
# cue_wait_patcher.py
# Play media; Space pauses/resumes VIDEO ONLY and records either:
#   - relative waits: self.wait(dt)   (default), or
#   - absolute stamps: self.wait_to('HH:MM:SS.mmm')  (--use-wait-to)
# Optional separate audio keeps playing during Space pauses. 'p' toggles global pause/resume for BOTH video and audio.
# Inserts after '# CUE [section]' markers, with optional '--section' filtering.
# Generated lines are tagged '# CUE_APPLIED ...' so re-runs replace instead of duplicating.

import argparse
import os
import re
import shutil
import sys
import time
from dataclasses import dataclass
from typing import List, Optional

# Playback: python-vlc
try:
    import vlc
except Exception:
    print("python-vlc is required. pip install python-vlc")
    raise

# Global hotkeys: pynput
try:
    from pynput import keyboard
except Exception:
    print("pynput is required. pip install pynput")
    raise


APPLIED_TAG = "CUE_APPLIED"  # tag for generated lines to avoid re-matching


@dataclass
class Marker:
    line_idx: int
    indent: str
    section: Optional[str] = None
    label: Optional[str] = None


# Matches in the comment portion only:
#   CUE
#   CUE 2
#   CUE 2: after product
#   CUE myPart - something
COMMENT_CUE_REGEX = re.compile(
    r"^\s*CUE(?:\s+([A-Za-z0-9_-]+))?(?:\s*:?[\s]*(.*))?$",
    re.IGNORECASE,
)


def fmt_ms(ms: int) -> str:
    # ms -> 'HH:MM:SS.mmm'
    if ms < 0:
        ms = 0
    s, ms = divmod(ms, 1000)
    h, s = divmod(s, 3600)
    m, s = divmod(s, 60)
    return f"{h:02d}:{m:02d}:{s:02d}.{ms:03d}"


def find_markers(lines: List[str]) -> List[Marker]:
    markers: List[Marker] = []
    for i, line in enumerate(lines):
        # Ignore any line already generated by this tool
        if APPLIED_TAG in line:
            continue

        # Find first '#' which starts the comment for this line (inline or comment-only)
        hash_pos = line.find("#")
        if hash_pos < 0:
            continue

        pre = line[:hash_pos].rstrip()
        comment = line[hash_pos + 1 :].strip()

        # Skip generated waits or helper waits on code lines
        # We still allow inline markers (e.g., "...  # CUE ..."), but not after our own self.wait insertions.
        if "self.wait" in pre or "self.wait_to" in pre:
            continue

        m = COMMENT_CUE_REGEX.match(comment)
        if not m:
            continue

        # Indentation: align insert at the block indent (not at the hash)
        indent = line[: len(line) - len(line.lstrip(" \t"))]
        section = (m.group(1) or None)
        raw_label = (m.group(2) or "").strip()
        label = raw_label or None

        markers.append(Marker(line_idx=i, indent=indent, section=section, label=label))

    return markers


def patch_file_with_waits(
    code_path: str,
    waits: List[float],
    marker_tag: str = "CUE",
    section_filter: Optional[str] = None,
    replace_existing: bool = True,
) -> int:
    with open(code_path, "r", encoding="utf-8") as f:
        lines = f.readlines()

    all_markers = find_markers(lines)
    if not all_markers:
        print(f"No '# {marker_tag}' markers found in {code_path}. Nothing to patch.")
        return 0

    # Filter by requested section (exact string match). If None, use all markers.
    if section_filter is not None:
        section_filter = str(section_filter)
        markers = [m for m in all_markers if m.section == section_filter]
    else:
        markers = all_markers

    if not markers:
        print(f"Found {len(all_markers)} total markers, but 0 match --section {section_filter!r}.")
        return 0

    n_apply = min(len(waits), len(markers))
    if n_apply == 0:
        print(f"Found {len(markers)} matching markers for section {section_filter!r}, but no waits captured.")
        return 0

    section_str = repr(section_filter) if section_filter is not None else "ALL"
    print(
        f"Found {len(all_markers)} total markers; {len(markers)} match section {section_str}. "
        f"Applying {n_apply} insert(s)."
    )

    new_lines: List[str] = []
    applied = 0
    marker_indices = {m.line_idx: m for m in markers}
    skip_next = set()

    i = 0
    while i < len(lines):
        if i in skip_next:
            i += 1
            continue

        line = lines[i]
        new_lines.append(line)

        if i in marker_indices and applied < n_apply:
            m = marker_indices[i]
            dt = waits[applied]

            parts = [APPLIED_TAG]
            if m.section:
                parts.append(str(m.section))
            parts.append(str(applied + 1))
            comment = "  # " + " ".join(parts)
            if m.label:
                comment += f" - {m.label}"

            insert_line = f"{m.indent}self.wait({dt:.3f}){comment}\n"

            if replace_existing and i + 1 < len(lines):
                nxt = lines[i + 1]
                if ("self.wait" in nxt or "self.wait_to" in nxt) and (APPLIED_TAG in nxt):
                    new_lines.append(insert_line)
                    skip_next.add(i + 1)
                else:
                    new_lines.append(insert_line)
            else:
                new_lines.append(insert_line)

            applied += 1

        i += 1

    backup_path = code_path + ".bak"
    shutil.copyfile(code_path, backup_path)
    with open(code_path, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

    print(f"Patched {applied} wait(s). Backup saved to {backup_path}.")
    if len(waits) > applied:
        print(f"Note: {len(waits) - applied} captured wait(s) not used (more waits than matching markers).")
    if len(markers) > applied:
        print(f"Note: {len(markers) - applied} matching marker(s) left unpatched (fewer waits than markers).")
    return applied


def patch_file_with_abs_stamps(
    code_path: str,
    stamps: List[str],
    marker_tag: str = "CUE",
    section_filter: Optional[str] = None,
    replace_existing: bool = True,
) -> int:
    with open(code_path, "r", encoding="utf-8") as f:
        lines = f.readlines()

    all_markers = find_markers(lines)
    if not all_markers:
        print(f"No '# {marker_tag}' markers found in {code_path}. Nothing to patch.")
        return 0

    if section_filter is not None:
        section_filter = str(section_filter)
        markers = [m for m in all_markers if m.section == section_filter]
    else:
        markers = all_markers

    if not markers:
        print(f"Found {len(all_markers)} total markers, but 0 match --section {section_filter!r}.")
        return 0

    n_apply = min(len(stamps), len(markers))
    if n_apply == 0:
        print(f"Found {len(markers)} matching markers for section {section_filter!r}, but no timestamps captured.")
        return 0

    section_str = repr(section_filter) if section_filter is not None else "ALL"
    print(
        f"Found {len(all_markers)} total markers; {len(markers)} match section {section_str}. "
        f"Applying {n_apply} insert(s)."
    )

    new_lines: List[str] = []
    applied = 0
    marker_indices = {m.line_idx: m for m in markers}
    skip_next = set()

    i = 0
    while i < len(lines):
        if i in skip_next:
            i += 1
            continue

        line = lines[i]
        new_lines.append(line)

        if i in marker_indices and applied < n_apply:
            m = marker_indices[i]
            stamp = stamps[applied]

            parts = [APPLIED_TAG]
            if m.section:
                parts.append(str(m.section))
            parts.append(str(applied + 1))
            comment = "  # " + " ".join(parts)
            if m.label:
                comment += f" - {m.label}"

            insert_line = f"{m.indent}self.wait_to('{stamp}'){comment}\n"

            if replace_existing and i + 1 < len(lines):
                nxt = lines[i + 1]
                if ("self.wait" in nxt or "self.wait_to" in nxt) and (APPLIED_TAG in nxt):
                    new_lines.append(insert_line)
                    skip_next.add(i + 1)
                else:
                    new_lines.append(insert_line)
            else:
                new_lines.append(insert_line)

            applied += 1

        i += 1

    backup_path = code_path + ".bak"
    shutil.copyfile(code_path, backup_path)
    with open(code_path, "w", encoding="utf-8") as f:
        f.writelines(new_lines)

    print(f"Patched {applied} wait_to() call(s). Backup saved to {backup_path}.")
    if len(stamps) > applied:
        print(f"Note: {len(stamps) - applied} captured timestamp(s) not used (more stamps than matching markers).")
    if len(markers) > applied:
        print(f"Note: {len(markers) - applied} matching marker(s) left unpatched (fewer stamps than markers).")
    return applied


def main():
    parser = argparse.ArgumentParser(
        description=(
            "Play media; Space pauses/resumes VIDEO ONLY and records waits. "
            "Use --use-wait-to to record absolute timestamps instead. "
            "Optional separate audio keeps playing. 'p' toggles global pause/resume for BOTH."
        )
    )
    parser.add_argument("--media", required=True, help="Path to video file (or audio if no --audio provided)")
    parser.add_argument("--audio", help="Optional separate audio file to play concurrently (won't pause on Space)")
    parser.add_argument("--code", required=True, help="Path to your scene .py file to patch")
    parser.add_argument("--marker", default="CUE", help="Marker tag in code comments (default: CUE)")
    parser.add_argument(
        "--section",
        help="Only patch markers that match this CUE section (e.g., 2). If omitted, all CUE markers are considered.",
    )

    # Behavior flags
    parser.add_argument("--use-wait-to", action="store_true", help="Insert self.wait_to('HH:MM:SS.mmm') instead of self.wait(dt)")
    parser.add_argument(
        "--abs-source",
        choices=["auto", "audio", "video"],
        default="auto",
        help="Clock for wait_to stamps: 'audio' if provided (default via 'auto'), else 'video'.",
    )
    parser.add_argument(
        "--abs-offset-ms",
        type=int,
        default=0,
        help="Add this offset (ms) to captured wait_to timestamps (use negative to subtract).",
    )

    # Keys and timing
    parser.add_argument("--key", default="space", help="Key to start/stop a timing gap (video-only pause) (default: space)")
    parser.add_argument("--pausekey", default="p", help="Key to toggle normal pause/resume for BOTH video and audio (default: p)")
    parser.add_argument("--quit", default="esc", help="Key to stop and patch (default: esc)")
    parser.add_argument("--quantize", type=float, default=0.05, help="Round waits to nearest step (sec), e.g., 0.05 (default)")
    parser.add_argument("--min-wait", type=float, default=0.00, help="Minimum wait recorded (seconds)")
    parser.add_argument("--max-wait", type=float, default=30.0, help="Maximum wait recorded (seconds)")
    parser.add_argument("--video-volume", type=int, default=100, help="Video volume 0–100 (default 100)")
    parser.add_argument("--audio-volume", type=int, default=100, help="Audio volume 0–100 (default 100)")
    parser.add_argument("--audio-offset-ms", type=int, default=0, help="Start audio delayed by N ms (can be negative on some platforms)")
    parser.add_argument(
        "--no-replace",
        action="store_true",
        help="Do not replace existing CUE_APPLIED waits; always insert new lines (default is to replace).",
    )
    args = parser.parse_args()

    media_path = args.media
    code_path = args.code
    audio_path = args.audio

    if not os.path.exists(media_path):
        print(f"Media file not found: {media_path}")
        sys.exit(1)
    if not os.path.exists(code_path):
        print(f"Code file not found: {code_path}")
        sys.exit(1)
    if audio_path and not os.path.exists(audio_path):
        print(f"Audio file not found: {audio_path}")
        sys.exit(1)

    # Build players
    instance = vlc.Instance()
    video_player = instance.media_player_new()
    video_media = instance.media_new_path(os.path.abspath(media_path))
    video_player.set_media(video_media)
    video_player.audio_set_volume(max(0, min(100, args.video_volume)))

    audio_player = None
    if audio_path:
        audio_player = instance.media_player_new()
        audio_media = instance.media_new_path(os.path.abspath(audio_path))
        audio_player.set_media(audio_media)
        audio_player.audio_set_volume(max(0, min(100, args.audio_volume)))

    # Start playback
    print("Starting playback...")
    if video_player.play() == -1:
        print("Failed to play media.")
        sys.exit(1)

    # Optional offset for audio
    time.sleep(0.25)
    if audio_player:
        if args.audio_offset_ms > 0:
            time.sleep(args.audio_offset_ms / 1000.0)
        if audio_player.play() == -1:
            print("Warning: failed to start audio. Continuing with video only.")
            audio_player = None
        else:
            if args.audio_offset_ms < 0:
                try:
                    audio_player.set_time(max(0, video_player.get_time() + args.audio_offset_ms))
                except Exception:
                    pass

    # Choose absolute clock source
    def get_abs_ms() -> int:
        src = args.abs_source
        if src == "auto":
            src = "audio" if audio_player is not None else "video"
        t = -1
        if src == "audio" and audio_player is not None:
            t = audio_player.get_time()
        else:
            t = video_player.get_time()
        if t is None or t < 0:
            t = 0
        return t + int(args.abs_offset_ms)

    waits: List[float] = []
    stamps_ms: List[int] = []
    mode = "idle"           # idle | timing_pause | global_pause
    hold_start: Optional[float] = None
    quitting = False

    print("\nControls:")
    print(f"- Press {args.key} to pause VIDEO ONLY (start timing); press {args.key} again to resume video and record "
          + ("timestamp (wait_to)" if args.use_wait_to else "wait duration (self.wait)"))
    print(f"- Press {args.pausekey} to toggle NORMAL pause/resume for BOTH video AND audio (no cue recorded)")
    print(f"- Press {args.quit} to stop and patch the file\n")

    def normalize_key(k):
        if isinstance(k, keyboard.Key):
            return str(k).split(".")[-1]  # 'space', 'esc', etc.
        try:
            return k.char
        except AttributeError:
            return str(k)

    def pause_video():
        try:
            video_player.set_pause(True)
        except Exception:
            video_player.pause()

    def play_video():
        try:
            video_player.set_pause(False)
        except Exception:
            video_player.pause()

    def pause_audio():
        if not audio_player:
            return
        try:
            audio_player.set_pause(True)
        except Exception:
            audio_player.pause()

    def play_audio():
        if not audio_player:
            return
        try:
            audio_player.set_pause(False)
        except Exception:
            audio_player.pause()

    def on_press(k):
        nonlocal mode, hold_start, quitting
        nk = normalize_key(k)

        if nk == args.key:
            # Timing pause/resume — VIDEO ONLY
            if mode == "idle":
                pause_video()
                hold_start = time.perf_counter()
                mode = "timing_pause"
                print("Timing pause: video paused, audio keeps playing")
            elif mode == "timing_pause":
                if args.use_wait_to:
                    t_ms = get_abs_ms()
                    stamps_ms.append(max(0, t_ms))
                    print(f"Timing resume: recorded stamp {fmt_ms(t_ms)} (total stamps: {len(stamps_ms)})")
                else:
                    now = time.perf_counter()
                    dt = (now - hold_start) if hold_start is not None else 0.0
                    dt = max(args.min_wait, min(dt, args.max_wait))
                    if args.quantize > 0:
                        dt = round(dt / args.quantize) * args.quantize
                    waits.append(dt)
                    print(f"Timing resume: recorded wait {dt:.3f}s (total waits: {len(waits)})")
                hold_start = None
                play_video()
                mode = "idle"
            elif mode == "global_pause":
                print("Currently globally paused; resume with", args.pausekey)

        elif nk == args.pausekey:
            # Normal pause/resume — BOTH video and audio; no cues recorded here
            if mode == "idle":
                pause_video()
                pause_audio()
                mode = "global_pause"
                print("Global pause: video and audio paused")
            elif mode == "timing_pause":
                # In absolute mode, do NOT create a stamp here (no unpause happened).
                # In relative mode, finalize the wait so you don't lose it.
                if not args.use_wait_to:
                    now = time.perf_counter()
                    dt = (now - hold_start) if hold_start is not None else 0.0
                    dt = max(args.min_wait, min(dt, args.max_wait))
                    if args.quantize > 0:
                        dt = round(dt / args.quantize) * args.quantize
                    waits.append(dt)
                    print(f"Global pause: recorded wait {dt:.3f}s; video and audio paused")
                else:
                    print("Global pause: video and audio paused")
                hold_start = None
                mode = "global_pause"
            elif mode == "global_pause":
                play_video()
                play_audio()
                mode = "idle"
                print("Global resume: video and audio playing")

        elif nk == args.quit:
            quitting = True
            return False  # stop listener

    with keyboard.Listener(on_press=on_press) as listener:
        try:
            while not quitting:
                v_state = video_player.get_state()
                a_state = audio_player.get_state() if audio_player else vlc.State.NothingSpecial
                if (v_state in (vlc.State.Ended, vlc.State.Error, vlc.State.Stopped)) and \
                   (audio_player is None or a_state in (vlc.State.Ended, vlc.State.Error, vlc.State.Stopped)):
                    print(f"Playback finished (video: {v_state}, audio: {a_state}). Exiting capture loop.")
                    break
                time.sleep(0.03)
        finally:
            try:
                video_player.stop()
            except Exception:
                pass
            if audio_player:
                try:
                    audio_player.stop()
                except Exception:
                    pass
            listener.stop()

    if args.use_wait_to:
        if stamps_ms:
            print("\nCaptured timestamps:")
            for i, ms in enumerate(stamps_ms, 1):
                print(f"  {i:02d}: {fmt_ms(ms)}")
        else:
            print("\nNo timestamps captured.")
        stamps = [fmt_ms(ms) for ms in stamps_ms]
        applied = patch_file_with_abs_stamps(
            code_path,
            stamps,
            marker_tag=args.marker,
            section_filter=args.section,
            replace_existing=not args.no_replace,
        )
        print(f"Done. Inserted {applied} self.wait_to(...) call(s).")
    else:
        if waits:
            print("\nCaptured waits:")
            for i, w in enumerate(waits, 1):
                print(f"  {i:02d}: {w:.3f}s")
        else:
            print("\nNo waits captured.")
        applied = patch_file_with_waits(
            code_path,
            waits,
            marker_tag=args.marker,
            section_filter=args.section,
            replace_existing=not args.no_replace,
        )
        print(f"Done. Inserted {applied} self.wait(...) call(s).")


if __name__ == "__main__":
    main()
