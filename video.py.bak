from collections.abc import Iterable
import manim
from manim.mobject.geometry.line import Line
from manim.animation.speedmodifier import ChangeSpeed
from manim.constants import PI
from manim.mobject.value_tracker import ValueTracker
from manim.mobject.geometry.arc import Dot
from manim.mobject.types.point_cloud_mobject import Point
from manim.mobject.graphing.coordinate_systems import ComplexPlane
from manim.utils.color.manim_colors import WHITE, BLACK
# from manim.animation.indication import Indicate
from manim.utils.color.manim_colors import PINK
from manim.utils.color.manim_colors import PURPLE
from manim.utils.color.manim_colors import BLUE
from manim.utils.color.manim_colors import GREEN
from manim.utils.color.manim_colors import YELLOW
from manim.utils.color.manim_colors import ORANGE
from manim.utils.color.manim_colors import RED
from manim.mobject.svg.brace import BraceLabel
from manim import VGroup, Rectangle
from typing import Callable, List
from manim.animation.animation import Animation
from manim.animation.creation import Create
# from manim.mobject.geometry.shape_matchers import SurroundingRectangle
from manim.animation.growing import GrowArrow
from manim.mobject.geometry.line import Arrow
from manim.mobject.mobject import Mobject
from manim.animation.transform import ReplacementTransform, FadeToColor
from manim.mobject.text.tex_mobject import MathTex
from manim.animation.transform import Restore
from manim import Scene, Text, Tex, Write, Unwrite, FadeOut, DOWN, UP, LEFT, RIGHT, Transform, FadeIn, ManimColor, config, FullScreenRectangle
import numpy as np
from manim import AnimationGroup

accents = [ManimColor("#ba0062ff"), ManimColor("#cdab8fff"), ManimColor("#a252f4ff"), ManimColor("#c44353ff"), ManimColor("#825d8fff"), ManimColor("#cadaf6ff"), ManimColor("#5b7376ff")]
pre_angle = 0

class ColoredMathTex(manim.MathTex):
    def __init__(self, *tex_strings,
                 arg_separator: str = " ",
                 substrings_to_isolate: Iterable[str] | None = ["h", r"\alpha", "r", "w", "m", "q", "k"],
                 tex_to_color_map: dict[str, ManimColor] = {},
                 tex_environment: str = "align*",
                 **kwargs
    ):
        super().__init__(*tex_strings, arg_separator=arg_separator, substrings_to_isolate=substrings_to_isolate, tex_to_color_map=tex_to_color_map, tex_environment=tex_environment, **kwargs)
        d: dict[str, ManimColor] = {
            "h": accents[0],
            r"\alpha": accents[1],
            "r": accents[2],
            "w": accents[3],
            "m": accents[1],
            "q": accents[1],
            "k": accents[6]
        }
        for var, key in d.items():
            self.set_color_by_tex(var, key)


# def auto_color(mob: MathTex):
#     vars: dict[str, ManimColor] = {
#         "h": accents[0],
#         r"\alpha": accents[1],
#         "r": accents[2],
#         "w": accents[3],
#         "m": accents[1],
#         "q": accents[1],
#         "k": accents[6]
#     }
#     for var, color in vars.items():
#         # mt("1", "2x", "3"); text[1][1].whatever()
#         for idx, text in enumerate(mob.tex_strings):
#             if -1 < idx < len(mob.tex_strings):
#                 loc = text.find(var)
#                 if -1 < loc < len(mob.tex_strings):
#                     mob[idx][loc].set_color(color)

# auto_color(eq)

MathTex = manim.MathTex
mt = MathTex

config.background_color = "#241f31ff"

def rearrange(a, b):
    return a.animate.scale_to_fit_height(b.height).move_to(b)

def rearrangeWhole(a, b, corr):
    buffer = []

    for i in range(len(corr)):
        if corr[i] == "f":
            buffer.append(FadeOut(a[0][i]))
        elif corr[i] == "i":
            buffer.append(FadeIn(a[0][i]))
        elif corr[i] == "n":
            pass
        elif corr[i] > -1:
            buffer.append(a[0][i].animate.scale_to_fit_height(b[0][corr[i]].height).move_to(b[0][corr[i]]))
        else:
            buffer.append(a[0][i].animate.scale_to_fit_height(b[0][-corr[i]].height).move_to(b[0][-corr[i]]).become(b[0][-corr[i]]))

    return buffer

def setColor(obj, pos, colors):
    for i in range(len(pos)):
        for j in range(len(pos[i])):
            obj[i][pos[i][j]].set_color(accents[colors[i][j]])
    return obj

def var_color(mob: Mobject, vars: List[str], colors: List[ManimColor]):
    for var in vars:
        mob.set_color_by_tex()

class Indicate(manim.Indicate):
    def __init__(self, mobject, color=None, **kwargs):
        super().__init__(mobject, color=color, **kwargs)

def SurroundingRectangle(*args, buff = 0.1):
    return manim.SurroundingRectangle(*args, color = "#825d8fff", buff = buff)

def indexAlign(a, b, indexA, indexB):
    return b[indexB[0]][indexB[1]].get_center() - a[indexA[0]][indexA[1]].get_center()

class Cyclo(Scene):
    level = [0, 0, 0]

    def hide_all(self, anim: Callable[[Mobject], Animation] = FadeOut):
        if self.mobjects is not None and len(self.mobjects) != 0:
            self.play(
                *[anim(mob) for mob in self.mobjects]
                # All mobjects in the screen are saved in self.mobjects
            )

    def section(self):
        self.hide_all()
        self.level[0] += 1
        self.level[1] = 0
        self.level[2] = 0

    def subsection(self):
        self.hide_all()
        self.level[1] += 1

    def subsubsection(self):
        self.hide_all()
        self.level[2] += 1

    def titlecard(self, title: str, mob: Mobject | None = None):
        bg = FullScreenRectangle().set_fill(ManimColor("#38304cff"), opacity=1).set_stroke(opacity=0)
        subt = (
            "" if self.level[1] == 0 and self.level[2] == 0
            else f".{self.level[1]}" if self.level[2] == 0
            else f".{self.level[1]}.{self.level[2]}")
        ident = str(self.level[0]) + subt
        text = Tex(f"{ident} {title}")
        text.to_edge(UP + LEFT)  # pyrefly: ignore
        if mob is not None:
            self.play(FadeIn(bg), FadeIn(text), FadeIn(mob))
            self.wait(1)
            self.play(FadeOut(bg), FadeOut(text), FadeOut(mob))
        else:
            if self.level[1] == 0:
                text.move_to(np.array((0, 0, 0)))
            self.play(FadeIn(bg), FadeIn(text))
            self.play(FadeOut(bg), FadeOut(text))
        self.next_section(ident)

    def divisors(self, n):
        divs = []

        for i in range(1,n+1):
            if n%i == 0:
                divs.append(i)

        return divs

    def intro(self):
        self.section()
        titlecard = mt(r"2^{2^\alpha} + 1")
        titlecard[0][2].set_color(accents[1])
        self.titlecard("Something Familiar", titlecard)

        fermat_full = MathTex(r"p = 2^h + 1")
        # CUE
        fermat_full[0][3].set_color(accents[0])
        fermat_full.save_state()
        self.play(Write(fermat_full))

        fermat = MathTex(r"p = 2^{2^\alpha} + 1")
        # CUE
        fermat[0][4].set_color(accents[1])
        fermat.set_x(fermat_full[0][1].get_x()-fermat[0][1].get_x())
        self.play(Transform(fermat_full[0][3], fermat[0][3:5]), fermat_full[0][-2].animate.move_to(fermat[0][-2]), fermat_full[0][-1].animate.move_to(fermat[0][-1]))

        down_arr = MathTex(r"\downarrow")
        down_arr.next_to(fermat, DOWN)

        fermat_examples = Text("e.g. 3, 5, 17", font_size=15)
        fermat_examples.next_to(down_arr, DOWN)
        self.play(Write(fermat_examples), FadeIn(down_arr))
        self.play(FadeOut(fermat_examples), FadeOut(down_arr))

        # CUE
        self.play(FadeOut(fermat_full))

        proof_line_1 = MathTex(r"h = rw\text{, }w\text{ is odd}")
        proof_line_1[0][0].set_color(accents[0])
        proof_line_1[0][2].set_color(accents[2])
        proof_line_1[0][3].set_color(accents[3])
        proof_line_1[0][5].set_color(accents[3])
        self.play(Write(proof_line_1))
        downarrow = MathTex(r"\downarrow", font_size = 90)
        proof_line_2 = MathTex(r"2^{r}+1\equiv 0 \mod{2^{r}+1}")
        proof_line_2[0][1].set_color(accents[2])
        proof_line_2[0][-3].set_color(accents[2])

        self.play(proof_line_1.animate.shift(2*UP))
        #proof_req.animate.shift(3*UP),

        downarrow.move_to([0,0.6,0])
        proof_line_2.move_to([0,-0.8,0])
        self.play(Write(downarrow), Write(proof_line_2))
        proof_line_3 = MathTex(r"2^{r}\equiv -1 \mod{2^{r}+1}")
        proof_line_3.shift(indexAlign(proof_line_3, proof_line_2, [0, 2], [0, 4]))
        #self.play(Write(proof_line_3))
        proof_line_4 = MathTex(r"2^{r w}\equiv (-1)^w \mod{2^{r}+1}")
        proof_line_4[0][2].set_color(accents[3])
        proof_line_4[0][8].set_color(accents[3])
        proof_line_4.shift(indexAlign(proof_line_4, proof_line_3, [0, 3], [0, 2]))
        proof_line_5 = MathTex(r"2^{r w}\equiv -1 \mod{2^{r}+1}")
        proof_line_5.shift(indexAlign(proof_line_5, proof_line_4, [0, 3], [0, 3]))
        proof_line_6 = MathTex(r"2^{r w}+1 \equiv 0 \mod{2^{r}+1}")
        proof_line_6.shift(indexAlign(proof_line_6, proof_line_5, [0, 5], [0, 3]))
        proof_line_7 = MathTex(r"2^{r}+1 \mid 2^{r w} + 1")
        proof_line_7.shift(indexAlign(proof_line_7, proof_line_6, [0, 4], [0, 5]))

        self.play(*rearrangeWhole(proof_line_2, proof_line_3, [0, 1, -3, 4, 2, "f", 5, 6, 7, 8, 9, 10, 11]))
        self.play(*rearrangeWhole(proof_line_2, proof_line_4, [0, 1, 5, 6, 3, "n", 9, 10, 11, 12, 13, 14, 15]), *[Write(proof_line_4[0][i]) for i in [2, 4, 7, 8]])
        self.play(*rearrangeWhole(proof_line_2, proof_line_5, [0, 1, 4, 5, 3, "n", 6, 7, 8, 9, 10, 11, 12]), *[FadeOut(proof_line_4[0][i]) for i in [4, 7, 8]])
        self.play(*rearrangeWhole(proof_line_2, proof_line_6, [0, 1, -3, 4, 5, "i", 7, 8, 9, 10, 11, 12, 13]), proof_line_4[0][2].animate.move_to(proof_line_6[0][2]))
        self.play(*rearrangeWhole(proof_line_2, proof_line_7, [5, 6, 8, 9, -4, "f", "f", "f", "f", 0, 1, 2, 3]), proof_line_4[0][2].animate.move_to(proof_line_7[0][-3]))

        statement = VGroup(proof_line_2[0][:5], proof_line_2[0][-4:], proof_line_4[0][2])
        self.play(statement.animate.shift([-statement[0][4].get_x(), 0, 0]))

        equals = mt("=").move_to(proof_line_2[0][4])
        self.play(ReplacementTransform(proof_line_2[0][4], equals))

        newEq = mt("w=1").next_to(equals, DOWN)
        newEq[0][0].set_color(accents[3])
        newEq.shift([-newEq[0][1].get_x(), 0, 0])
        self.play(Write(newEq))

        final = mt(r"h=2^\alpha").next_to(newEq, DOWN)
        final[0][0].set_color(accents[0])
        final[0][-1].set_color(accents[1])
        final.shift([-final[0][1].get_x(), 0, 0]).shift(DOWN)
        self.play(Write(final))
        self.play(Indicate(final))

        self.subsection()

        cyclo_ex = MathTex(r"""
            \Phi_1(x) &= x - 1 \\
            \Phi_2(x) &= x + 1 \\
            \Phi_3(x) &= x^2 + x + 1 \\
            \Phi_4(x) &= x^2 + 1 \\
            \Phi_5(x) &= x^4 + x^3 + x^2 + x + 1 \\
            \Phi_6(x) &= x^2 - x + 1\\
        """)
        self.titlecard("Something New?", cyclo_ex)

        new_fact = MathTex(r"\text{If }b\geq2&:", r"\\ &p = b^{hm} + b^{h(m-1)} + ...+ b^{h} + 1")
        setColor(new_fact, [[2], [2,6,-4,3,7,-3,4,9]], [[2],[2,2,2,0,0,0,1,1]])

        new_fact.to_edge(UP)

        conc_from_fact = Tex(r"$m+1$ is prime, $h$ is a power of $m+1$")
        setColor(conc_from_fact, [[0, 11, -3]], [[1, 0, 1]])

        fact_arr = MathTex(r"\Downarrow", font_size = 90)
        fact_arr.next_to(new_fact, DOWN)
        fact_arr.set_y(0.5*(new_fact.get_edge_center(DOWN)[1]+conc_from_fact.get_edge_center(UP)[1]))

        self.play(Write(new_fact))
        self.play(Write(conc_from_fact), Write(fact_arr))

        fact_highlight = SurroundingRectangle(new_fact[1], conc_from_fact, buff=.1)
        self.play(Create(fact_highlight))

        self.hide_all()

        fermat_bin = MathTex("2^{h}+1 = 1", "00...01", "_{2}")
        fermat_bin[0][1].set_color(accents[0])
        self.play(Write(fermat_bin))
        bin_brace = BraceLabel(fermat_bin[1], "h")
        bin_brace[1].set_color(accents[0])
        self.play(Create(bin_brace))

        self.hide_all()

        base_b_fact = MathTex(r"\left(b^{h}\right)^{m} + \left(b^{h}\right)^{m-1} + ... + b^{h} + 1 = 1", "00...01",
                              "00..01", "...", "00...01", "_{b}")
        setColor(base_b_fact, [[1, 7, -6, 2, 8, -5], [], [], [], [], [-1]], [[2, 2, 2, 0, 0, 0], [], [], [], [], [2]])
        self.play(Write(base_b_fact))
        base_b_braces = [
            BraceLabel(base_b_fact[1], "h"),
            BraceLabel(base_b_fact[2], "h"),
            BraceLabel(base_b_fact[4], "h"),
        ]
        for i in range(3):
            base_b_braces[i][1].set_color(accents[0])

        self.play(*[Create(x) for x in base_b_braces])

        self.hide_all()

        line_1 = mt(r"\underbrace{10001}00&0\underbrace{10001}{}_b\nonumber\\")
        arr = mt(r"\downarrow").next_to(line_1, DOWN)
        line_2 = mt(r"10001{}_b&|1000100010001{}_b\nonumber").next_to(arr, DOWN)
        line_1[0][-1].set_color(accents[2])
        line_2[0][5].set_color(accents[2])
        line_2[0][-1].set_color(accents[2])

        self.play(Write(line_1))
        self.play(Write(arr))
        self.play(Write(line_2))

        self.hide_all()

        new_fact = MathTex(r"\text{If }b\geq2&\text{, }q\text{ is prime:}", r"\\ &p = b^{h(q-1)} + b^{h(q-2)} + ...+ b^{h} + 1")
        setColor(new_fact, [[2, 6], [2, 10, 22, 3, 11, 23, 5, 13]], [[2, 1], [2, 2, 2, 0, 0, 0, 1, 1]])

        new_fact.to_edge(UP)

        conc_from_fact = Tex(r"$h$ is a power of $q$")
        setColor(conc_from_fact, [[0, -1]], [[0, 1]])

        fact_arr = MathTex(r"\Downarrow", font_size=90)
        fact_arr.next_to(new_fact, DOWN)
        fact_arr.set_y(0.5 * (new_fact.get_edge_center(DOWN)[1] + conc_from_fact.get_edge_center(UP)[1]))

        self.play(Write(new_fact))
        self.play(Write(conc_from_fact), Write(fact_arr))
        self.hide_all()

        stick_figure = Tex("STICK FIGURE")  # i can make one for us :)
        self.play(Create(stick_figure))
        self.play(FadeOut(stick_figure))

        cyclotomic_examples = MathTex(r"\Phi_1(x) &= x - 1 \\ \Phi_2(x) &= x + 1 \\ \Phi_3(x) &= x^2 + x + 1 \\ \Phi_4(x) &= x^2 + 1 \\ "
                                      r"\Phi_5(x) &= x^4 + x^3 + x^2 + x + 1 \\ \Phi_6(x) &= x^2 - x + 1 \\ \Phi_7(x) &= x^6 + x^5 + x^4 + x^3 + x^2 + x + 1 \\ \Phi_8(x) &= x^4 + 1 \\"
                                      r"\Phi_9(x) &= x^6 + x^3 + 1 \\ \Phi_{10}(x) &= x^4 - x^3 + x^2 - x + 1")
        self.play(Write(cyclotomic_examples))

    def definitions(self):
        self.section()
        self.titlecard("Cyclotomic Polynomials", MathTex(r"\Phi_n(x)"))

        self.next_section("1", skip_animations = False)

        cyclo_examples = [MathTex(r"x-1", r"=", r"(x-1)"), MathTex(r"x^2-1", r"=", r"(x-1)", r"(x+1)"), MathTex(r"x^3-1", r"=", r"(x-1)", r"(x^2+x+1)"), MathTex(r"x^4-1", r"=", r"(x-1)", r"(x+1)", r"(x^2+1)"), MathTex(r"x^5-1", r"=", r"(x-1)", r"(x^4+x^3+x^2+x+1)"), MathTex(r"x^6-1", r"=", r"(x-1)", r"(x+1)", r"(x^2+x+1)", r"(x^2-x+1)"), MathTex(r"x^7-1", r"=", r"(x-1)", r"(x^6+x^5+x^4+x^3+x^2+x+1)")]

        lhs = VGroup(cyclo_examples[i][0] for i in range(7))
        equals_signs = VGroup(cyclo_examples[i][1] for i in range(7))
        rhs = VGroup(cyclo_examples[i][2:] for i in range(7))

        lhs.arrange(DOWN, aligned_edge=RIGHT, buff=0.5)

        for l, eq, r in zip(lhs, equals_signs, rhs):
            eq.next_to(l, RIGHT, buff=0.1)
            r.next_to(eq, RIGHT, buff=0.1)
            r.shift([0, l[0][0].get_y()-r[0][1].get_y(), 0])

        equations = VGroup(VGroup(l, eq, r) for l, eq, r in zip(lhs, equals_signs, rhs))
        equations.move_to((0,0,0))

        self.play(Write(equations))

        arrow = MathTex(r"\rightarrow")
        arrow.next_to(cyclo_examples[0][0], LEFT)

        self.play(Write(arrow))

        colors = [RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE, PINK]
        finished = [[] for i in range(7)]

        for i in range(7):
            divisors = self.divisors(i+1)
            for j in range(len(divisors)):
                divisor = divisors[j]
                finished[divisor-1].append(cyclo_examples[i][j+2])
                hue = colors[divisor-1]

                if j == len(divisors)-1:
                    self.play(finished[divisor-1][-1].animate.set_color(hue))
                self.play(Indicate(finished[divisor-1][0], color = str(hue)), Indicate(finished[divisor-1][-1], color = str(hue)))

            if(i != 6):
                self.play(arrow.animate.next_to(cyclo_examples[i+1][0][0], LEFT))
            else:
                self.play(FadeOut(arrow))

        self.play(*[Indicate(cyclo_examples[i][0], color = str(WHITE)) for i in range(7)])
        self.play(equations.animate.scale(0.5).move_to((0, 0, 0)))

        factorizations = [MathTex(r"{{(x-1)}}"), MathTex(r"{{(x+1)}}{{(x-1)}}"), MathTex(r"{{(x-e^{2\pi i \frac{1}{3} })(x-e^{2\pi i \frac{2}{3} })}}{{(x-1)}}"),
                          MathTex(r"{{(x-e^{2\pi i \frac{1}{4} })(x-e^{2\pi i \frac{3}{4} })}}{{(x+1)}}{{(x-1)}}"), MathTex(r"{{(x-e^{2\pi i \frac{1}{5} })(x-e^{2\pi i \frac{2}{5} })(x-e^{2\pi i \frac{3}{5} })(x-e^{2\pi i \frac{4}{5} })}}{{(x-1)}}"),
                          MathTex(r"{{(x-e^{2\pi i \frac{1}{6} })(x-e^{2\pi i \frac{5}{6} })}}{{(x-e^{2\pi i \frac{1}{3} })(x-e^{2\pi i \frac{2}{3} })}}{{(x+1)}}{{(x-1)}}"),
                          MathTex(r"{{(x-e^{2\pi i \frac{1}{7} })(x-e^{2\pi i \frac{2}{7} })(x-e^{2\pi i \frac{3}{7} })(x-e^{2\pi i \frac{4}{7} })(x-e^{2\pi i \frac{5}{7} })(x-e^{2\pi i \frac{6}{7} })}}{{(x-1)}}")]

        newLHS = VGroup(*factorizations)
        newLHS.arrange(DOWN, aligned_edge=RIGHT, buff=0.5)
        newLHS.scale(0.5)
        newLHS.move_to((-2.28, 0, 0))

        self.play(*[VGroup(equals_signs[i], rhs[i]).animate.next_to(factorizations[i][-1][-1], RIGHT, buff=0.05) for i in range(7)], ReplacementTransform(lhs, newLHS))

        newFinished = [[] for i in range(7)]

        arrow.next_to(factorizations[0], LEFT)
        self.play(Write(arrow))

        for i in range(7):
            divisors = self.divisors(i+1)
            for j in range(len(divisors)):
                divisor = divisors[j]
                newFinished[divisor-1].append(factorizations[i][len(divisors) - j - 1])
                hue = colors[divisor-1]

                if j == len(divisors)-1:
                    self.play(newFinished[divisor-1][-1].animate.set_color(hue))
                self.play(Indicate(newFinished[divisor-1][0], color = str(hue)), Indicate(newFinished[divisor-1][-1], color = str(hue)))

            if(i != 6):
                self.play(arrow.animate.next_to(factorizations[i+1][0], LEFT))
            else:
                self.play(FadeOut(arrow))

        #fading out irrelevant terms
        irrelevantTermsList = []

        for i in range(7):
            for j in range(1, len(self.divisors(i+1))):
                irrelevantTermsList.append(factorizations[i][j])

        for i in range(7):
            for j in range(len(self.divisors(i+1))):
                if j != len(self.divisors(i+1))-1:
                    irrelevantTermsList.append(cyclo_examples[i][j+2])
                else:
                    irrelevantTermsList.append(cyclo_examples[i][-1][0])
                    irrelevantTermsList.append(cyclo_examples[i][-1][-1])

        self.play(*[FadeOut(i) for i in irrelevantTermsList])

        #reordering the relevant terms (swapping LHS and RHS)

        newRHS = VGroup(factorizations[i][0] for i in range(7))
        newLHS = VGroup(cyclo_examples[i][-1][1:len(cyclo_examples[i][-1])-1] for i in range(7))
        animations = []
        eqX = -2.05

        for r, eq, l in zip(newRHS, equals_signs, newLHS):
            deltaX = eq.get_x()-eq.get_edge_center(LEFT)[0]

            animations.append(eq.animate.move_to((eqX, eq.get_y(), 0)))
            animations.append(r.animate.move_to((eqX+deltaX+0.1, eq.get_y(), 0), aligned_edge = LEFT))
            animations.append(l.animate.move_to((eqX-deltaX-0.1, eq.get_y(), 0), aligned_edge = RIGHT))

        self.play(*animations)

        #changing everything to white
        self.play(*[i.animate.set_color(WHITE) for i in newLHS], *[i.animate.set_color(WHITE) for i in newRHS])

        #highlighting denominators row-by-row
        for i in range(2,7):
            buffer = []
            for j in range(len(newRHS[i])):
                if j%11 == 9:
                    buffer.append(newRHS[i][j])

            self.play(*[Indicate(k, color = colors[i], scale_factor = 3) for k in buffer], time=2)

        #give an alternative form of lines 1 and 2
        alt1 = MathTex(r"=(x-e^{2 \pi i \frac{0}{1}})")
        alt1.scale(0.5)
        alt1.next_to(newRHS[0], direction = RIGHT, buff = 0.1)
        alt1.shift([0,newRHS[0].get_edge_center(DOWN)[1]-alt1.get_edge_center(DOWN)[1],0])

        self.play(Write(alt1))
        self.play(Indicate(alt1[0][-2], color = RED, scale_factor = 3), time = 2)

        preAlt2 = MathTex(r"=(x-(-1))")
        preAlt2.scale(0.5)
        preAlt2.next_to(newRHS[1], direction=RIGHT, buff=0.1)

        alt2 = MathTex(r"=(x-e^{2 \pi i \frac{1}{2}})")
        alt2.scale(0.5)
        alt2.next_to(newRHS[1], direction=RIGHT, buff=0.1)
        alt2.shift([0, newRHS[1].get_edge_center(DOWN)[1] - alt2.get_edge_center(DOWN)[1], 0])

        self.play(Write(preAlt2))
        self.play(ReplacementTransform(preAlt2, alt2))
        self.play(Indicate(alt2[0][-2], color = ORANGE, scale_factor = 3), time = 2)

        ex = mt(r"(x-e^{2 \pi i \frac{4}{6}})")
        ex.scale(0.5)
        ex.next_to(newRHS[5], RIGHT, buff = 0.1)
        exTemplate = mt(r"(x-e^{2 \pi i \frac{2}{3}})")
        exTemplate.scale(0.5)
        exTemplate.next_to(newRHS[2], RIGHT, buff = 0.1)

        self.play(Write(ex))
        self.play(*rearrangeWhole(ex, exTemplate, [0, 1, 2, 3, 4, 5, 6, -7, 8, -9, 10]))
        self.play(FadeOut(ex, shift = [newRHS[2][-1].get_center()-ex[0][-1].get_center()]))

        #writing formula for cyclotomic polynomials
        self.play(*[i.animate.shift(UP) for i in newLHS], *[i.animate.shift(UP) for i in newRHS], *[i.animate.shift(UP) for i in equals_signs], alt1.animate.shift(UP), alt2.animate.shift(UP))

        etc = MathTex(r"\vdots")
        etc.next_to(equals_signs[-1], direction = DOWN, buff = 0.5)

        self.play(Write(etc))

        self.next_section("4", skip_animations = False)

        newEq = MathTex(r"\Phi_n(x)", r"=", r"\prod_{\substack{0 \le k < n\\\frac{k}{n} \text{ is fully reduced} } } \left(x - e^{2\pi i \frac{k}{n} } \right)")
        setColor(newEq, [[1], [], [5, 8, -2, 3, 6, -4]], [[0], [], [0, 0, 0, 6, 6, 6]])
        newEq[1].next_to(etc, direction = DOWN, buff = 0.1)
        newEq[1].shift(np.array([0, -1, 0]))
        newEq[0].next_to(newEq[1], direction = LEFT, buff = 0.1)
        newEq[2].next_to(newEq[1], direction=RIGHT, buff=0.1)

        self.play(Write(newEq))

        productAlt = MathTex(r"\substack{\gcd(k,n) = 1}")
        setColor(productAlt, [[4, 6]], [[6, 0]])
        productAlt.move_to(newEq[2][6:23])

        self.play(Transform(newEq[2][6:23], productAlt))

        eqBox = SurroundingRectangle(newEq, buff = 0.1)
        self.play(Create(eqBox))

        boxedEq = VGroup(eqBox, newEq, productAlt)
        self.play(boxedEq.animate.shift(LEFT*2.5))

        arrow = mt(r"\rightarrow").next_to(boxedEq, direction=RIGHT, buff = 0.1)
        rootsStatement = mt(r"\text{Roots are:}", r"e^{2\pi i \frac{k}{n}}", r"\text{where } \gcd(k,n) = 1")
        setColor(rootsStatement, [[], [4, 6], [9, 11]], [[], [6, 0], [6, 0]])
        rootsStatement.arrange(DOWN)
        rootsStatement.next_to(arrow, RIGHT)
        self.play(Write(arrow), Write(rootsStatement))

        self.next_section("2", skip_animations = False)
        #primes section

        self.subsection()
        titlecard = mt(r"x^{q-1}+x^{q-2}+...+x+1")
        setColor(titlecard, [[1, 6]], [[1, 1]])
        self.titlecard("For Primes", titlecard)

        cyclo_examples_p = [mt(r"\Phi_1(x)", "=", "x - 1"), mt(r"\Phi_2(x)", "=", "x + 1"), mt(r"\Phi_3(x)", "=", r"x^2 + x + 1"), mt(r"\Phi_4(x)", "=", r"x^2 + 1"),
            mt(r"\Phi_5(x)", "=", r"x^4 + x^3 + x^2 + x + 1"), mt(r"\Phi_6(x)", "=", r"x^2 - x + 1"), mt(r"\Phi_7(x)", "=", r"x^6 + x^5 + x^4 + x^3 + x^2 + x + 1")]

        lhs = VGroup(cyclo_examples_p[i][0] for i in range(7))
        equals_signs = VGroup(cyclo_examples_p[i][1] for i in range(7))
        rhs = VGroup(cyclo_examples_p[i][2:] for i in range(7))

        lhs.arrange(DOWN, aligned_edge=RIGHT, buff=0.5)

        for l, eq, r in zip(lhs, equals_signs, rhs):
            eq.next_to(l, RIGHT, buff=0.1)
            r.next_to(eq, RIGHT, buff=0.1)

        equations = VGroup(VGroup(l, eq, r) for l, eq, r in zip(lhs, equals_signs, rhs))
        equations.move_to((0, 0, 0))

        self.play(Write(equations))

        primeRows = VGroup(*[cyclo_examples_p[i-1] for i in [2,3,5,7]])
        nonPrimeRows = VGroup(*[cyclo_examples_p[i-1] for i in [1,4,6]])
        self.play(FadeOut(nonPrimeRows), primeRows.animate.arrange(DOWN, aligned_edge = LEFT))

        animGroupList = []

        for i in range(7):
            buffer = []
            for j in range(4):
                maxIndex = 3*([2,3,5,7][j]-2)+2
                if 3*i+3 <= maxIndex:
                    buffer.append(primeRows[j][2][3*i:3*i+2])
                elif 3*i < maxIndex:
                    buffer.append(primeRows[j][2][3*i])
                elif 3*i-3 < maxIndex:
                    buffer.append(primeRows[j][2][maxIndex])

            animGroupList.append(Indicate(VGroup(*buffer)).set_run_time(0.5))

        animGroup = AnimationGroup(*animGroupList, lag_ratio = 0.2)
        self.play(animGroup)


            # self.play(*[Indicate(primeRows[j][2][i]) for j in range(4) if [2,3,5,7][j] >= i], time = 0.65)

        newLHS = mt(r"\Phi_q(x)")
        newRHS = mt(r"x^{q-1}+x^{q-2}+...+x+1")
        newLHS[0][1].set_color(accents[1])
        setColor(newRHS, [[1, 6]], [[1, 1]])
        eq = mt("=")
        qmark = mt("?")
        eq.move_to(equals_signs)
        newLHS.next_to(eq, direction = LEFT)
        newRHS.next_to(eq, direction = RIGHT)
        qmark.next_to(newRHS, direction = RIGHT)
        equation = VGroup(newLHS, eq, newRHS)

        self.play(ReplacementTransform(primeRows, equation))
        self.play(Write(qmark))
        equation = VGroup(newLHS, eq, newRHS)
        self.play(FadeOut(qmark))
        self.play(Indicate(equation, color = WHITE))

        geo_form = mt(r"\frac{x^q-1}{x-1}")
        geo_form[0][1].set_color(accents[1])
        geo_form.next_to(equation[1], direction = RIGHT)
        self.play(Transform(equation[2], geo_form))
        self.play(equation.animate.shift([-equation[1].get_x(), -equation[1].get_y(), -equation[1].get_z()]))

        phi_p = mt(r"\prod_{\substack{0 \le k < q\\gcd(k,q) = 1}} \left(x - e^{2\pi i \frac{k}{q}} \right)")
        setColor(phi_p, [[3, 10, -4, 5, 12, -2]], [[6, 6, 6, 1, 1, 1]])
        phi_p.next_to(equation[1], direction = LEFT)
        self.play(Transform(equation[0], phi_p))

        newSubstack = mt(r"\substack{q\nmid k}")
        setColor(newSubstack, [[0, 2]], [[1, 6]])
        newSubstack1 = mt(r"\substack{k \neq 0}")
        setColor(newSubstack1, [[0]], [[6]])

        newSubstack.move_to(equation[0][0][6:16])
        newSubstack1.move_to(equation[0][0][6:16])

        self.play(equation[0][0][6:16].animate.become(newSubstack))
        self.play(equation[0][0][6:16].animate.become(newSubstack1))
        self.play(FadeOut(equation[0][0][6:16]))
        one = mt(r"\substack{1}")
        one.move_to(equation[0][0][1])
        self.play(equation[0][0][1].animate.become(one))

        newFraction = mt(r"\frac{\prod_{\substack{0 \le k < q}} \left(x - e^{2\pi i \frac{k}{q}} \right)}{x-1}")
        setColor(newFraction, [[3, -8, 5, -6]], [[6, 6, 1, 1]])
        newFraction.next_to(equation[1], direction = RIGHT)
        self.play(ReplacementTransform(equation[2][0][4], newFraction[0][17]), ReplacementTransform(equation[2][0][:4], newFraction[0][:17]), ReplacementTransform(equation[2][0][5:], newFraction[0][18:]))

        exponentialForm = mt(r"e^0")
        exponentialForm.next_to(newFraction[0][19], direction = RIGHT)
        self.play(Transform(newFraction[0][20], exponentialForm))

        exponentialForm = mt(r"e^{2\pi i \frac{0}{q}}")
        setColor(exponentialForm, [[-1]], [[1]])
        exponentialForm.next_to(newFraction[0][19], direction=RIGHT)
        self.play(Transform(newFraction[0][20], exponentialForm))

        one.move_to(newFraction[0][1])
        self.play(FadeOut(newFraction[0][17:]), Transform(newFraction[0][1], one))

        newRHS = phi_p.copy()
        newRHS.next_to(eq, direction = RIGHT)
        newRHS.shift([0, phi_p.get_y()-newRHS.get_y(), 0])

        self.play(newFraction[0][0].animate.scale_to_fit_height(newRHS[0][0].height).move_to(newRHS[0][0]), newFraction[0][1:6].animate.move_to(newRHS[0][1:6]), newFraction[0][6:17].animate.move_to(newRHS[0][16:27]))

        self.play(Indicate(newFraction[0][:17]), Indicate(equation[0][0][:6]), Indicate(equation[0][0][16:]))

        self.hide_all()

        new_fact = MathTex(r"\text{If }b\geq2&\text{, } q \text{ is prime:}", r"\\ &p", "=", r"(b^h)^{q-1} + (b^h)^{q-2} + ...+ b^{h} + 1")
        setColor(new_fact, [[2, 6], [], [], [1, 9, 20, 2, 10, 21, 4, 12]], [[2, 1], [], [], [2, 2, 2, 0, 0, 0, 1, 1]])
        new_fact.to_edge(UP)

        conc_from_fact = Tex(r"$h$ is a power of $q$")
        setColor(conc_from_fact, [[0, -1]], [[0, 1]])

        fact_arr = MathTex(r"\Downarrow", font_size=90)
        fact_arr.next_to(new_fact, DOWN)
        fact_arr.set_y(0.5 * (new_fact.get_edge_center(DOWN)[1] + conc_from_fact.get_edge_center(UP)[1]))

        self.play(Write(new_fact))
        self.play(Write(conc_from_fact), Write(fact_arr))

        newRHS = mt(r"\Phi_q(b^h)")
        setColor(newRHS, [[1, -2, -3]], [[1, 0, 2]])
        newRHS.next_to(new_fact[2], direction = RIGHT)

        self.play(ReplacementTransform(new_fact[3], newRHS))
        self.play(new_fact[1:].animate.shift([fact_arr.get_x()-new_fact[1:].get_x(), 0, 0]))

        self.wait(4)

    def the_result(self):
        self.section()
        self.titlecard("The Central Result")

        divis_test_17 = mt(r"17\mid 123743 \rightarrow \text{ not prime}")
        # CUE 3
        self.play(Write(divis_test_17[0][3:9]))
        # CUE 3
        self.play(Write(divis_test_17[0][:3]), Write(divis_test_17[0][9:]))

        divis = mt(r"P(x)\mid \Phi_q(x^h)").next_to(divis_test_17[0][9], LEFT)
        setColor(divis, [[-2, -5]], [[0, 1]])
        qmark = mt("?").next_to(divis_test_17[0][-1], RIGHT)
        # CUE 3
        self.play(ReplacementTransform(divis_test_17[0][:9], divis))
        self.play(Write(qmark))

        Phihq = mt(r"\Phi_{hq}(x)")
        setColor(Phihq, [[-4, -5]], [[1, 0]])
        Phihq.shift(divis[0][2].get_center()-Phihq[0][4].get_center())
        # CUE 3
        self.play(ReplacementTransform(divis[0][0], Phihq[0][:3]))

        titlecard = mt(r"\Phi_{hq}(x)\mid\Phi_q(x^h)")
        setColor(titlecard, [[1, -2, 2, -5]], [[0, 0, 1, 1]])

        self.subsection()
        self.titlecard("Divisibility", titlecard)

        prod = mt(r"\Phi_n(x)=\prod_{\substack{0\leq k < n \\ \gcd(k,n) = 1}}\left(x-e^{2\pi i \frac{k}{n}}\right)")
        prod2 = mt(r"\Phi_{hq}(x)=\prod_{\substack{0\leq k < hq \\ \gcd(k,hq) = 1}}\left(x-e^{2\pi i \frac{k}{hq}}\right)")
        setColor(prod, [[1, 11, 18, -2, 9, 16, -4]], [[0, 0, 0, 0, 6, 6, 6]])
        setColor(prod2, [[1, 12, 20, -3, 2, 13, 21, -2, 10, 18, -5]], [[0, 0, 0, 0, 1, 1, 1, 1, 6, 6, 6]])

        self.play(Write(prod))
        self.play(prod.animate.become(prod2))
        self.play(prod.animate.to_edge(UP))

        lrarrow = mt(r"\Leftrightarrow").move_to(np.array([0,0,0]))
        divis = mt(r"\Phi_{hq}(x)\mid\Phi_q(x^h)").next_to(lrarrow, LEFT)
        setColor(divis, [[1, -2, 2, -5]], [[0, 0, 1, 1]])
        multi = VGroup(
                mt(r"(x-e^{2\pi i \frac{1}{hq}})\mid \Phi_q(x^h)"),
                mt(r"\vdots"),
                mt(r"(x-e^{2\pi i \frac{hq-1}{hq}})\mid \Phi_q(x^h)"),
        ).arrange(DOWN).next_to(lrarrow, RIGHT)
        setColor(multi[0], [[-2, -10, -5, -9]], [[0, 0, 1, 1]])
        setColor(multi[2], [[-2, -10, -15, -5, -9, -14]], [[0, 0, 0, 1, 1, 1]])


        self.play(FadeIn(lrarrow), Write(divis))
        self.play(Write(multi))

        new_multi = VGroup(
                mt(r"&\forall \ 0\leq k < hq \text{ where}\\ &", r"\gcd(k,hq)=1\text{:}", font_size=30),
                mt(r"(x-e^{2\pi i \frac{k}{hq}})\mid \Phi_q(x^h)")
        ).arrange(DOWN, buff = 0.5).move_to(multi)
        setColor(new_multi[0], [[3, 5, 6], [4, 6, 7]], [[6, 0, 1], [6, 0, 1]])
        setColor(new_multi[1], [[-2, -10, -5, -9, -12]], [[0, 0, 1, 1, 6]])

        self.play(ReplacementTransform(multi, new_multi))

        new_multi1 = VGroup(
                mt(r"&\forall \ 0\leq k < hq \text{ where}\\ &\gcd(k,hq)=1\text{:}", font_size=30),
                mt(r"\Phi_q(x^h)\mid_{e^{2\pi i \frac{k}{hq}}} = 0")
        ).arrange(DOWN, buff = 0.5).move_to(multi)

        self.play(*rearrangeWhole(new_multi[1], new_multi1[1], ["f", "f", "f", 7, 8, 9, 10, 11, 12, 13, 14, "f", 6, 0, 1, 2, 3, 4, 5]), FadeIn(new_multi1[1][0][-2:]))

        new_multi2 = VGroup(
                mt(r"&\forall \ 0\leq k < hq \text{ where}\\ &\gcd(k,hq)=1\text{:}", font_size=30),
                mt(r"\Phi_q\left(\left(e^{2\pi i \frac{k}{hq}}\right)^h\right) = 0")
        ).arrange(DOWN, buff = 0.5).move_to(multi)
   
        self.play(*rearrangeWhole(new_multi[1], new_multi2[1], ["n", "n", "n", 4, 5, 6, 7, 8, 9, 10, 11, "n", "f", 0, 1, 2, "f", 13, 14]), FadeIn(new_multi2[1][0][3]), FadeIn(new_multi2[1][0][12]), new_multi1[1][0][-2:].animate.move_to(new_multi2[1][0][-2:]))

        new_multi3 = VGroup(
                mt(r"&\forall \ 0\leq k < hq \text{ where}\\ &\gcd(k,hq)=1\text{:}", font_size=30),
                mt(r"\Phi_q\left(e^{2\pi i \frac{k}{q}}\right) = 0")
        ).arrange(DOWN, buff = 0.5).move_to(multi)

        self.play(*rearrangeWhole(new_multi[1], new_multi3[1], ["n", "n", "n", 3, 4, 5, 6, 7, 8, "f", 9, "n", "n", 0, 1, 2, "n", "f", 10]), FadeOut(new_multi2[1][0][3]), FadeOut(new_multi2[1][0][12]), new_multi1[1][0][-2:].animate.move_to(new_multi3[1][0][-2:]))

        new_multi4 = VGroup(
                mt(r"&\forall \ 0\leq k < hq \text{ where}\\ &", r"\gcd(k,h)=1 \text{ and } \gcd(k, q)=1\text{:}", font_size=30),
                mt(r"\Phi_q\left(e^{2\pi i \frac{k}{q}}\right) = 0")
        ).arrange(DOWN, buff = 0.5).move_to(multi)

        setColor(new_multi4[0], [[], [4, 6, -7, -5]], [[], [6, 0, 6, 1]])

        LHS = VGroup(*[new_multi[1][0][i] for i in [3,4,5,6,7,8,10,13,14,15,18]])
        newEq = VGroup(LHS, new_multi1[1][0][-2], new_multi1[1][0][-1])
      
        self.play(*rearrangeWhole(new_multi, new_multi4, ["n",-1]), newEq.animate.shift([0, new_multi4[1].get_y()-newEq.get_y(), 0]))

        self.play(Indicate(new_multi[0][1][-11:-1]))

        zeq = mt(r"0 = 0").next_to(new_multi4[0], DOWN)

        self.play(Transform(newEq[0], zeq[0][0]), newEq[1].animate.move_to(zeq[0][1]), newEq[2].animate.move_to(zeq[0][2]))

        self.play(Indicate(newEq))
        self.play(FadeOut(lrarrow), FadeOut(new_multi[0]), FadeOut(newEq), divis.animate.move_to(np.array((0,0,0))))

        Q_mult = mt(r"Q(x)\cdot\Phi_{hq}(x)=\Phi_q(x^h)")
        where_q = mt(r"\Phi_q(x^h)=\prod_{\substack{\text{for some} \\ \text{k where} \\ 1 \leq k < hq }} \left(x-e^{2\pi i \frac{k}{hq} }\right) ").next_to(Q_mult, DOWN)
        arrow = mt(r"\nearrow").next_to(where_q, DOWN)
        might_be = Tex(r"might be empty")
        arrow.shift([where_q[0][6].get_x()-arrow[0][0].get_x(), 0, 0])
        might_be.next_to(arrow, LEFT)
        might_be.shift(DOWN*0.5)
        setColor(Q_mult, [[6, -2, 7, -5]], [[0, 0, 1, 1]])
        setColor(where_q, [[1, 4, 15, 23, -5, 25, -3, 26, -2]], [[1, 0, 6, 6, 6, 0, 0, 1, 1]])

        self.play(*rearrangeWhole(divis, Q_mult, [5, 6, 7, 8, 9, 10, -11, 12, 13, 14, 15, 16, 17]), Write(Q_mult[0][:5]))
        self.play(Write(where_q))

        qx = mt(r"Q(x)")
        qx.next_to(where_q[0][6], LEFT)

        self.play(ReplacementTransform(where_q[0][:6], qx))
        self.play(Write(arrow), Write(might_be))
        
        highBox = SurroundingRectangle(Q_mult, buff = 0.1)
        self.play(Create(highBox))

        self.subsection()
        self.subsection()
        self.titlecard("Complex Magnitudes", mt(r"\|a+bi\|=\sqrt{a^2+b^2}"))

        monic_polys = mt(r"Q(x)", r"\cdot", r"\Phi_{hq}(x)", "=", r"\Phi_q(x^h)")
        setColor(monic_polys, [[], [], [1, 2], [], [1, -2]], [[], [], [0, 1], [], [1, 0]])
        arrows = mt(r"\nwarrow\ &\ \ \ \nearrow").next_to(monic_polys, DOWN)
        arrows.shift(np.array((monic_polys[3].get_x() - arrows.get_x(), 0, 0)))
        label = Tex(r"monic integer polynomials").next_to(arrows, DOWN)

        self.play(Write(monic_polys))
        self.wait()
        self.play(Write(arrows), FadeIn(label))
        self.play(Indicate(monic_polys[2]),Indicate(monic_polys[-1]))
        self.play(Indicate(monic_polys[0]))
        self.play(FadeOut(arrows), FadeOut(label))

        new_exp = mt(r"Q(b)", r"\cdot", r"\Phi_{hq}(b)", "=", r"\Phi_q(b^h)")
        setColor(new_exp, [[2], [], [1, 2, -2], [], [1, -2, -3]], [[2], [], [0, 1, 2], [], [1, 0, 2]])

        self.play(ReplacementTransform(monic_polys[0][:2], new_exp[0][:2]),
                  ReplacementTransform(monic_polys[0][2], new_exp[0][2]),
                  ReplacementTransform(monic_polys[0][3], new_exp[0][3]),
                  ReplacementTransform(monic_polys[1], new_exp[1]),
                  ReplacementTransform(monic_polys[2][:4], new_exp[2][:4]),
                  ReplacementTransform(monic_polys[2][4], new_exp[2][4]),
                  ReplacementTransform(monic_polys[2][5], new_exp[2][5]),
                  ReplacementTransform(monic_polys[3:], new_exp[3:]))

        eq_b = mt("= p")
        eq_b.next_to(monic_polys, RIGHT)
        eq_b.shift([0, monic_polys[3].get_y()-eq_b[0][0].get_y(), 0])
        self.play(Write(eq_b))
        self.play(FadeOut(new_exp[-1]), FadeOut(new_exp[-2]), eq_b.animate.shift([monic_polys[3].get_x()-eq_b[0][0].get_x(), 0, 0]))

        monic_polys_b1 = mt(r"|Q(b)|", r"\cdot", r"|\Phi_{hq}(b)|")
        setColor(monic_polys_b1, [[3], [], [2, 3, 5]], [[2], [], [0, 1, 2]])
        monic_polys_b1.next_to(eq_b[0][0], direction = LEFT)

        self.play(new_exp[0].animate.move_to(monic_polys_b1[0]), new_exp[1].animate.move_to(monic_polys_b1[1]), new_exp[2].animate.move_to(monic_polys_b1[2]))
        self.play(Write(monic_polys_b1[i][j]) for i,j in zip([0,2,2,0], [0,-1,0,-1]))

        eq1 = mt(r"|\Phi_{hq}(b)|", "=", "1")
        setColor(eq1, [[2, 3, 5], [], []], [[0, 1, 2], [], []])
        orz = Tex("or")
        eq2 = mt(r"|Q(b)|", "=", "1")
        setColor(eq2, [[3], [], []], [[2], [], []])

        eq1.next_to(monic_polys[1], DOWN)
        eq1.shift(DOWN)
        orz.next_to(eq1, DOWN)
        eq2.next_to(orz, DOWN)

        eq2.shift([eq1[1].get_x()-eq2[1].get_x(), 0, 0])

        self.play(AnimationGroup(Write(eq1), Write(orz), Write(eq2), lag_ratio = 0.2))

        new_eq = VGroup(monic_polys_b1[0][0], monic_polys_b1[0][-1], monic_polys_b1[2][0], monic_polys_b1[2][-1], new_exp[0:3], eq_b)
        self.play(FadeOut(orz), new_eq.animate.to_edge(UP))

        self.play(eq1.animate.shift(3*UP), eq2.animate.shift(UP))

        mag_phi_hq = mt(r"|\Phi_{hq}(b)|", "=", r"\Big\|", r"\prod_{\substack{1 \leq k < hq \\ \gcd(k, hq)=1} }", r"(b-e^{2\pi i \frac{k}{hq} })", r"\Big\|")
        mag_phi_hq2 = mt(r"|\Phi_{hq}(b)|", "=", r"\prod_{\substack{1 \leq k < hq \\ \gcd(k, hq)=1} }", r"\Big\|", r"b-e^{2\pi i \frac{k}{hq} }", r"\Big\|")
        setColor(mag_phi_hq, [[2, 3, 5], [], [], [3, 11, 5, 13, 6, 14], [1, -5, -3, -2], []], [[0, 1, 2], [], [], [6, 6, 0, 0, 1, 1], [2, 6, 0, 1], []])
        setColor(mag_phi_hq2, [[2, 3, 5], [], [3, 11, 5, 13, 6, 14], [], [1, -5, -3, -2], []], [[0, 1, 2], [], [6, 6, 0, 0, 1, 1], [], [2, 6, 0, 1], []])
        mag_phi_hq.shift(np.array(eq1[1].get_center().tolist())-np.array(mag_phi_hq[1].get_center().tolist()))
        mag_phi_hq2.shift(np.array(eq1[1].get_center().tolist())-np.array(mag_phi_hq2[1].get_center().tolist()))

        mag_q  = mt(r"|Q(b)|", "=", r"\Big\|", r"\prod_{\substack{\text{for some} \\ \text{k where} \\ 1 \leq k < hq } }", r"(b-e^{2\pi i \frac{k}{hq} })", r"\Big\|").next_to(mag_phi_hq, DOWN)
        mag_q2 = mt(r"\left|Q(b)\right|", "=", r"\prod_{\substack{\text{for some} \\ \text{k where} \\ 1 \leq k < hq } }", r"\Big\|", r"b-e^{2\pi i \frac{k}{hq} }", r"\Big\|").next_to(mag_phi_hq, DOWN)
        setColor(mag_q, [[3], [], [], [8, 16, -2, -1], [1, -5, -3, -2], []],
                 [[2], [], [], [6, 6, 0, 1], [2, 6, 0, 1], []])
        setColor(mag_q2, [[3], [], [9, 16, -2, -1], [], [1, -5, -3, -2], []],
                 [[2], [], [6, 6, 0, 1], [], [2, 6, 0, 1], []])
        mag_q.shift(np.array(eq2[1].get_center().tolist()) - np.array(mag_q[1].get_center().tolist()))
        mag_q2.shift(np.array(eq2[1].get_center().tolist()) - np.array(mag_q2[1].get_center().tolist()))

        self.play(ReplacementTransform(eq1[:2], mag_phi_hq[:2]),
                  ReplacementTransform(eq2[:2], mag_q[:2]),
                  ReplacementTransform(eq1[2], mag_phi_hq[2:]),
                  ReplacementTransform(eq2[2], mag_q[2:]))

        self.play(ReplacementTransform(mag_phi_hq[:2], mag_phi_hq2[:2]),
                  ReplacementTransform(mag_q[:2], mag_q2[:2]),
                  rearrange(mag_phi_hq[2], mag_phi_hq2[3]),
                  rearrange(mag_q[2], mag_q2[3]),
                  rearrange(mag_phi_hq[3], mag_phi_hq2[2]),
                  rearrange(mag_q[3], mag_q2[2]),
                  rearrange(mag_phi_hq[4][1:-1], mag_phi_hq2[4]),
                  rearrange(mag_q[4][1:-1], mag_q2[4]),
                  rearrange(mag_phi_hq[5], mag_phi_hq2[5]),
                  rearrange(mag_q[5], mag_q2[5]),
                  FadeOut(mag_phi_hq[4][0]),
                  FadeOut(mag_phi_hq[4][-1]),
                  FadeOut(mag_q[4][0]),
                  FadeOut(mag_q[4][-1]))

        mag1 = VGroup(mag_phi_hq[2], mag_phi_hq[4][1:-1], mag_phi_hq[5])
        mag2 = VGroup(mag_q[2], mag_q[4][1:-1], mag_q[5])

        self.play(Indicate(mag1), Indicate(mag2))

        self.wait()
        #self.next_section(name = "fart", skip_animations=True)
        self.subsubsection()
        titlecard = mt(r"\left\|b-e^{2\pi i\frac{k}{hq}}\right\|")
        setColor(titlecard, [[3, -7, -5, -4]], [[2, 6, 0, 1]])
        self.titlecard("", titlecard)

        plane = ComplexPlane(
            background_line_style={"stroke_opacity": 0},
        ).add_coordinates(
            -4, -3, -2, -1, 1, 2, 3, 4, 1.j, -1.j
        ).scale(5/3).shift([0,1.1,0])

        y_axis = plane.get_axes()[1]
        new_y_axis = Line(
            start=plane.c2p(0, -1.2),
            end=plane.c2p(0, plane.y_range[1]),
            stroke_width=y_axis.stroke_width
        )
        plane.remove(y_axis)
        plane.add(new_y_axis)

        moving_point = Dot(plane.n2p(1+0j), color=ManimColor("#cadaf6ff"), z_index=10)

        initial_value = PI / 4

        k = ValueTracker(initial_value)

        b_label = mt("b", font_size = 35, color = ManimColor("#cadaf6ff")).move_to(plane.n2p(2)).shift([0, 0.3, 0])
        b_point = Dot(plane.n2p(2), color = ManimColor("#cadaf6ff"), z_index=10)
                
        def eval_p(x) -> complex:
            return np.exp(1.j*x)

        def eval_rot(theta) -> float:
                return -np.arctan(np.sin(theta)/(2-np.cos(theta)))

        def cpx_str(z: complex) -> str:
            return str(np.around(z, 3)).replace("j", "i").replace(")", "").replace("(", "").replace("+", " + ").replace("-", " - ")

        origin_b_line = Line(plane.n2p(0), plane.n2p(2), color = GREEN)

        inner_radius = Line(np.array((0,0,0)), np.array((0,0,0)), stroke_width = 1.5, color = PINK)
        inner_radius.add_updater(lambda m: m.become(Line(
            plane.n2p(0),
            plane.n2p(eval_p(k.get_value())),
            stroke_width = 1.5,
            color = PINK
        )))
        
        outer_line = Line(np.array((0,0,0)), np.array((0,0,0)), stroke_width = 1.5, color = PINK)
        outer_line.add_updater(lambda m: m.become(Line(
            plane.n2p(eval_p(k.get_value())),
            plane.n2p(2), 0,
            stroke_width = 1.5,
            color = PINK
        )))

        value_label = mt(r"e^{i\theta}", font_size = 35, color = ManimColor("#cadaf6ff")).next_to(moving_point, UP, buff = 0.1).add_updater(
            lambda m: m.become (mt(rf"e^{{i {np.around(k.get_value()%6.28, 2)} }}", font_size = 35, color = ManimColor("#cadaf6ff")).next_to(moving_point, UP, buff = 0.1)) if k.get_value() != initial_value else m.next_to(moving_point, UP, buff = 0.1)
        )

        def smartRound(num):
            return str(num)+(4-len(str(num)))*"0"

        length_label = mt(r"\left\|b-e^{i \theta}\right\|", font_size = 25, color = ManimColor("#cadaf6ff"))
        setColor(length_label, [[2]], [[2]])
        length_label.add_updater(
                lambda m: (m.become(mt(rf"\left\|b-e^{{ i {smartRound(np.around(k.get_value()%6.28, 2))} }}\right\|", font_size = 25, color = ManimColor("#cadaf6ff")))
                        .move_to(plane.n2p((eval_p(k.get_value())+2)/2))
                        .shift( np.array([ 0, 0.2, 0 ]) )
                        .rotate( eval_rot( k.get_value() ))
                if k.get_value() != initial_value else
                    m.become(mt(r"\left\|b-e^{i \theta}\right\|", font_size = 25, color = ManimColor("#cadaf6ff")))
                        .move_to(plane.n2p((eval_p(k.get_value())+2)/2))
                        .shift( np.array([ 0, 0.2, 0 ]) )
                        .rotate( eval_rot( k.get_value() ))
                )
        )


        circle = plane.plot_parametric_curve(lambda t: np.array([np.cos(t), np.sin(t)]), t_range = [0, 2*PI], stroke_width = 1.5)

        moving_point.add_updater(lambda m: m.move_arc_center_to(plane.n2p(eval_p(k.get_value()))))
        moving_point.add_updater(lambda m: m.move_arc_center_to(plane.n2p(eval_p(k.get_value()))))

        self.play(Create(plane), Create(circle))
        self.play(Create(moving_point))
        self.play(Write(value_label))
        self.play(Write(b_label), Create(b_point))
        self.play(Create(inner_radius), Create(outer_line))
        self.play(Create(origin_b_line))
        self.play(Write(length_label))


        self.play(Indicate(origin_b_line))

        self.play(FadeToColor(outer_line, color=PINK), Indicate(outer_line), FadeToColor(inner_radius, color=PINK), Indicate(inner_radius))




        bottom_magni = mt(r"1", r"+", r"\left\|b-e^{i\theta}\right\|\geq b").to_edge(DOWN)
        setColor(bottom_magni, [[], [], [2, -1]], [[], [], [2, 2]])
        self.play(Write(bottom_magni))

        self.play(ChangeSpeed(k.animate.set_value(2*PI), speedinfo={0: 0.125}))

        theta_thing = mt(r"\theta = 2\pi\frac{k}{hq} \neq 0").next_to(bottom_magni, UP)
        setColor(theta_thing, [[-7, -5, -4]], [[6, 0, 1]])

        self.play(Write(theta_thing))

        bottom_magni2 = mt(r"1+\left\|b-e^{i\theta}\right\| > b").to_edge(DOWN)
        self.play(Unwrite(theta_thing), Transform(bottom_magni[2][-2], bottom_magni2[0][-2]))

        self.play(ChangeSpeed(k.animate.set_value(2*PI+PI/4), speedinfo={0: 1}))

        bottom_magni3 = mt(r"\left\|b-e^{i\theta}\right\| > b - 1")
        bottom_magni3.shift(np.array(bottom_magni[2][-2].get_center().tolist())-np.array(bottom_magni3[0][-4].get_center().tolist()))

        self.play(rearrange(bottom_magni[1], bottom_magni3[0][-2]), rearrange(bottom_magni[0], bottom_magni3[0][-1]), Transform(bottom_magni[1], bottom_magni3[0][-2]))

        rightmost = mt(r"\geq", "2 - 1")
        rightmost.next_to(bottom_magni[0], RIGHT)

        self.play(Write(rightmost))

        one = mt(r"1")
        one.next_to(rightmost[0], RIGHT)
        self.play(ReplacementTransform(rightmost[1], one))

        letGo = VGroup(bottom_magni[0], bottom_magni[1], bottom_magni[2][-1], rightmost[0])
        self.play(FadeOut(letGo), one.animate.next_to(bottom_magni[2][-2], RIGHT))

        surr_magni = SurroundingRectangle(bottom_magni[2][:-1], one, buff=0.1)
        self.play(Create(surr_magni))
        self.play(FadeOut(surr_magni))

        inner_radius.remove_updater(inner_radius.updaters[0])
        outer_line.remove_updater(outer_line.updaters[0])
        value_label.remove_updater(value_label.updaters[0])
        length_label.remove_updater(length_label.updaters[0])

        self.hide_all()


    def step_27(self):
        # Step 27
        self.hide_all()

        top27 = mt(r"|Q(b)|", r"\cdot", r"|\Phi_{hq}(b)| = p").shift(UP)
        top27.to_edge(UP)
        setColor(top27, [[3], [], [2,3, 5]], [[2], [], [0, 1, 2]])
        mid27 = mt(r"\prod_{\substack{1 \leq k < hq \\ \gcd(k, hq) = 1}} \| b-e^{i2\pi \frac{k}{hq}} \| = |\Phi_{hq} (b)|")
        setColor(mid27, [[3,5,6,11,13,14,19, 25,27,28,-5,-6,-3]], [[6,0,1,6,0,1,2,6,0,1,0,1, 2]])
        mid27.next_to(top27, DOWN)
        mid27.shift(DOWN)
        bot27 = mt(r"\prod_{\substack{\text{for some} \\ \text{k where} \\ 1 \leq k < hq}} \| b-e^{i2\pi \frac{k}{hq}} \| = |Q(b)|")
        setColor(bot27, [[8,16,18,19,21, -12,-10,-9, -3]], [[6,6,0,1,2,6,0,1, 2]])

        bot27.next_to(mid27, DOWN)
        bot27.shift(DOWN)

        self.play(Write(top27), Write(mid27), Write(bot27))
        self.wait()
        # Step 28

        d27 = mt(r"1 <")
        d27.next_to(mid27[0][0], LEFT)
        self.play(Write(d27))

        self.wait()

        # Step 29
        self.play(FadeOut(mid27), FadeOut(d27))
        d27 = mt(r"1 =")

        self.play(bot27.animate.move_to(mid27))
        d27.next_to(bot27[0][0], LEFT)
        self.play(Write(d27))

        self.wait()

        # Step 30
        nwarrow = mt(r"\nwarrow")
        prod = Tex(r"must be an empty product")

        nwarrow.next_to(mid27, DOWN)
        nwarrow.shift(LEFT)
        prod.next_to(nwarrow, DOWN + RIGHT)
        self.play(Write(nwarrow), Write(prod))

        # 31
        prod2 = mt(r"Q(x) = 1")
        prod2.next_to(nwarrow, DOWN + RIGHT)
        self.play(ReplacementTransform(prod, prod2))
        self.wait()

        # 32
        box = SurroundingRectangle(prod2)
        self.play(Write(box))
        self.wait()

        # 33
        self.hide_all()
        top33 = mt(r"Q(x)", r"\cdot", r"\Phi_{hq}(x) = \Phi_{q}(x^h)")
        setColor(top33,[[],[],[1,2,-5,-2]],[[],[],[0,1,1,0]])
        self.play(Write(top33))

        top33_p2 = mt(r"1", r"\cdot", r"\Phi_{hq}(x) = \Phi_{q}(x^h)")
        setColor(top33_p2,[[],[],[1,2,-5,-2]],[[],[],[0,1,1,0]])
        top33_p2.move_to(top33)
        self.play(ReplacementTransform(top33, top33_p2))

        self.wait()

        # 34
        print(top33_p2[0])
        # top33_p3 = mt(r"\Phi_{hq}(x) = \Phi_{q}(x^h)")
        # top33_p3.move_to(top33_p2)
        # self.play(Transform(top33_p2, top33_p3))
        self.play(FadeOut(top33_p2[0]), FadeOut(top33_p2[1]), top33_p2[2:].animate.move_to((0,0,0)))

        # 35
        box2 = SurroundingRectangle(top33_p2[2:])
        self.play(Write(box2))

        self.wait()

    def last_section(self):
        self.subsection()

        titlecard = mt("h=q^t")
        setColor(titlecard, [[0,2]],[[0,1]])

        self.titlecard("Wrapping Up", titlecard)

        poop_dimension = mt(r"\Phi_{hq}(x)", "=", r"\Phi_q(x^h)}}")
        setColor(poop_dimension,[[1,2],[],[1,4]],[[0,1],[],[1,0]])
        poop_arrows = mt(r"\nwarrow\ &\ \ \ \nearrow").next_to(poop_dimension, DOWN)
        poop_arrows.shift(np.array((poop_dimension[1].get_x() - poop_arrows.get_x(), 0, 0)))
        label = Tex(r"must have the same roots").next_to(poop_arrows, DOWN)

        self.play(Write(poop_dimension))
        self.play(Write(poop_arrows), Write(label))

        line1 = mt(r"/")
        line2 = mt(r"\backslash")
        set1 = mt(r"\{", r"e^{2\pi i \frac{k}{hq}}", r"\text{, where } \gcd(k,hq)=1\}")
        setColor(set1,[[],[4,6,7],[-8,-6,-5]],[[],[6,0,1],[6,0,1]])
        set2 = mt(r"\{", r"e^{2\pi i \frac{k}{hq}}", r"\text{, where } \gcd(k,q)=1\}")
        setColor(set2, [[],[4,6,7],[-7,-6,-5]],[[],[6,0,1],[6,0,1]])

        line1.next_to(poop_dimension[0], DOWN)
        line2.next_to(poop_dimension[2], DOWN)
        set1.next_to(line1, DOWN)
        set1.shift([0.7+line1.get_x()-set1[2][-1].get_x(), 0, 0])
        set2.next_to(line2, DOWN)
        set2.shift([line2.get_x() - set2[0][0].get_x()-0.7, 0, 0])

        derivation = mt(r"x^h=e^{2 \pi i \frac{k}{q}}", r"\text{where } \gcd(k,q)=1")
        setColor(derivation, [[1,-3,-1],[-6,-4]],[[0,6,1],[6,1]])
        derivation.arrange(DOWN).next_to(line2, DOWN)
        derivation.shift([line2.get_x()-derivation[0][0].get_x(), 0, 0])

        derivation1 = mt(r"x=e^{2 \pi i \frac{k}{hq}}")
        setColor(derivation1, [[-4,-2,-1]],[[6,0,1]])

        derivation1.shift(derivation[0][2].get_center()-derivation1[0][1].get_center())

        self.play(FadeOut(label), FadeOut(poop_arrows))
        self.play(Write(line1), Write(set1))
        self.play(Write(line2))
        self.play(Write(derivation))
        self.play(*rearrangeWhole(derivation, derivation1, [0, 8, 1, 2, 3, 4, 5, 6, -7, 9]))
        expThing = VGroup(derivation[0][3:], derivation[0][1])
        self.play(rearrange(expThing, set2[1]), rearrange(derivation[1], set2[2][1:-1]),
                  Write(set2[0]), Write(set2[2][:1]), Write(set2[2][-1]),
                  FadeOut(derivation[0][0]), FadeOut(derivation[0][2]))

        newButt = VGroup(set2[2][:1], derivation[1], set2[2][-1])
        newSet = VGroup(set2[0], expThing, newButt)

        self.play(FadeOut(poop_dimension[0]), FadeOut(poop_dimension[2]), FadeOut(line1), FadeOut(line2),
                  set1.animate.next_to(poop_dimension[1], LEFT), newSet.animate.next_to(poop_dimension[1], RIGHT))

        self.play(Indicate(set1[1][-4]), Indicate(derivation[0][-3]))

        kay1 = mt(r"\{", r"k", r"\text{, where } \gcd(k,hq)=1\}")
        setColor(kay1, [[],[0],[-8,-6,-5]],[[],[6],[6,0,1]])

        kay2 = mt(r"\{", r"k", r"\text{, where } \gcd(k,q)=1\}")
        setColor(kay2, [[],[0],[-7,-5]],[[],[6],[6,1]])
        kay1.next_to(poop_dimension[1], LEFT)
        kay2.next_to(poop_dimension[1], RIGHT)

        self.play(FadeOut(set1[1][:-4]), FadeOut(set1[1][-3:]),
                  FadeOut(derivation[0][3:-3]), FadeOut(derivation[0][-2:]), FadeOut(derivation[0][1]),
                  rearrange(set1[1][-4], kay1[1]),
                  rearrange(derivation[0][-3], kay2[1]),
                  rearrange(set1[0], kay1[0]),
                  rearrange(set2[0], kay2[0]),
                  rearrange(set1[2], kay1[2]),
                  rearrange(newButt, kay2[2]))

        equation = VGroup(set1[0], set1[1][-4], set1[2], poop_dimension[1], set2[0], derivation[0][-3], newButt)

        supposition = mt(r"\text{If there is prime } r\neq q \text{ where } r\mid h:").to_edge(UP)
        setColor(supposition, [[-10,-2]],[[1,0]])

        self.play(Write(supposition))

        gcd1 = mt(r"\gcd(r, hq)=r").next_to(supposition, DOWN)
        setColor(gcd1, [[-5,-4]],[[0,1]])
        gcd1.shift(gcd1.get_edge_center(RIGHT)[0]*LEFT)
        gcd2 = mt(r", \ \gcd(r, q)=1").next_to(supposition, DOWN)
        setColor(gcd2, [[-4]],[[1]])
        gcd2.shift(gcd2.get_edge_center(LEFT)[0]*LEFT)

        self.play(Write(gcd1))
        self.play(Write(gcd2))

        neq = mt(r"\neq").move_to(poop_dimension[1])

        self.play(Write(neq))
        self.play(AnimationGroup(Unwrite(neq), Unwrite(gcd2), Unwrite(gcd1), lag_ratio=0.2))

        strike = Line((supposition.get_edge_center(LEFT)[0]-0.3,supposition.get_edge_center(LEFT)[1],0), (supposition.get_edge_center(RIGHT)[0]+0.3,supposition.get_edge_center(RIGHT)[1],0))

        self.play(Create(strike))
        self.play(FadeOut(strike), FadeOut(supposition),
                  equation.animate.shift(UP))

        arr = mt(r"\downarrow").next_to(poop_dimension[1], DOWN)
        text_meow = Tex(r"The only prime divisor of $h$ is $q$").next_to(arr, DOWN)
        setColor(text_meow, [[-4,-1]], [[0,1]])
        text_meow2 = mt(r"h=q^t").next_to(arr, DOWN)
        setColor(text_meow2, [[0,2]], [[0,1]])

        self.play(Write(arr))
        self.play(Write(text_meow))

        self.play(Transform(text_meow, text_meow2))

        box = SurroundingRectangle(text_meow, buff=0.1)

        self.play(Create(box))

        self.hide_all()

        new_fact = MathTex(r"\text{If }b\geq2&\text{, } q \text{ is prime:}", r"\\ &p", "=",
                           r"\Phi_q(b^h)")
        setColor(new_fact, [[2, 6], [], [], [1,3,4]], [[2, 1],[],[],[1,2,0]])

        new_fact.to_edge(UP)

        conc_from_fact = Tex(r"$h$ is a power of $q$")
        setColor(conc_from_fact, [[0,-1]], [[0,1]])

        fact_arr = MathTex(r"\Downarrow", font_size=90)
        fact_arr.next_to(new_fact, DOWN)
        fact_arr.set_y(0.5 * (new_fact.get_edge_center(DOWN)[1] + conc_from_fact.get_edge_center(UP)[1]))

        new_fact[1:].shift([fact_arr.get_x() - new_fact[1:].get_x(), 0, 0])

        self.play(Write(new_fact))
        self.play(Write(conc_from_fact), Write(fact_arr))

    def epilogue(self):
        self.section()
        self.titlecard("Epilogue")

        poop_dimension = mt(r"\Phi_{ha}(x)", "=", r"\Phi_a(x^h)}}")
        setColor(poop_dimension,[[1,2],[],[1,4]],[[0,1],[],[1,0]])
        poop_arrows = mt(r"\nwarrow\ &\ \ \ \nearrow").next_to(poop_dimension, DOWN)
        poop_arrows.shift(np.array((poop_dimension[1].get_x() - poop_arrows.get_x(), 0, 0)))
        label = Tex(r"must have the same roots").next_to(poop_arrows, DOWN)

        self.play(Write(poop_dimension))
        self.play(Write(poop_arrows), Write(label))

        line1 = mt(r"/")
        line2 = mt(r"\backslash")
        set1 = mt(r"\{", r"e^{2\pi i \frac{k}{ha}}", r"\text{, where } \gcd(k,ha)=1\}")
        setColor(set1,[[],[4,6,7],[-8,-6,-5]],[[],[6,0,1],[6,0,1]])
        set2 = mt(r"\{", r"e^{2\pi i \frac{k}{ha}}", r"\text{, where } \gcd(k,a)=1\}")
        setColor(set2,[[],[4,6,7],[-7,-6,-5]],[[],[6,0,1],[6,0,1]])

        line1.next_to(poop_dimension[0], DOWN)
        line2.next_to(poop_dimension[2], DOWN)
        set1.next_to(line1, DOWN)
        set1.shift([0.7 + line1.get_x() - set1[2][-1].get_x(), 0, 0])
        set2.next_to(line2, DOWN)
        set2.shift([line2.get_x() - set2[0][0].get_x() - 0.7, 0, 0])

        derivation = mt(r"x^h=e^{2 \pi i \frac{k}{a}}", r"\text{where } \gcd(k,a)=1")
        setColor(derivation, [[1,-3,-1], [-6,-4]], [[0, 6, 1], [6, 1]])
        derivation.arrange(DOWN).next_to(line2, DOWN)
        derivation.shift([line2.get_x() - derivation[0][0].get_x(), 0, 0])

        derivation1 = mt(r"x=e^{2 \pi i \frac{k}{ha}}")#############
        derivation1.shift(derivation[0][2].get_center() - derivation1[0][1].get_center())

        self.play(FadeOut(label), FadeOut(poop_arrows))
        self.play(Write(line1), Write(set1))
        self.play(Write(line2))
        self.play(Write(derivation))
        self.play(*rearrangeWhole(derivation, derivation1, [0, 8, 1, 2, 3, 4, 5, 6, -7, 9]))
        expThing = VGroup(derivation[0][3:], derivation[0][1])
        self.play(rearrange(expThing, set2[1]), rearrange(derivation[1], set2[2][1:-1]),
                  Write(set2[0]), Write(set2[2][:1]), Write(set2[2][-1]),
                  FadeOut(derivation[0][0]), FadeOut(derivation[0][2]))

        newButt = VGroup(set2[2][:1], derivation[1], set2[2][-1])
        newSet = VGroup(set2[0], expThing, newButt)

        self.play(FadeOut(poop_dimension[0]), FadeOut(poop_dimension[2]), FadeOut(line1), FadeOut(line2),
                  set1.animate.next_to(poop_dimension[1], LEFT), newSet.animate.next_to(poop_dimension[1], RIGHT))

        self.play(Indicate(set1[1][-4]), Indicate(derivation[0][-3]))

        kay1 = mt(r"\{", r"k", r"\text{, where } \gcd(k,ha)=1\}")#########
        kay2 = mt(r"\{", r"k", r"\text{, where } \gcd(k,a)=1\}")#########
        kay1.next_to(poop_dimension[1], LEFT)
        kay2.next_to(poop_dimension[1], RIGHT)

        self.play(FadeOut(set1[1][:-4]), FadeOut(set1[1][-3:]),
                  FadeOut(derivation[0][3:-3]), FadeOut(derivation[0][-2:]), FadeOut(derivation[0][1]),
                  rearrange(set1[1][-4], kay1[1]),
                  rearrange(derivation[0][-3], kay2[1]),
                  rearrange(set1[0], kay1[0]),
                  rearrange(set2[0], kay2[0]),
                  rearrange(set1[2], kay1[2]),
                  rearrange(newButt, kay2[2]))

        equation = VGroup(set1[0], set1[1][-4], set1[2], poop_dimension[1], set2[0], derivation[0][-3], newButt)

        supposition = mt(r"\text{If there is prime } r\nmid a \text{ where } r\mid h:").to_edge(UP)
        setColor(supposition, [[-10, -2]], [[1, 0]])

        self.play(Write(supposition))

        gcd1 = mt(r"\gcd(r, ha)=r").next_to(supposition, DOWN)
        setColor(gcd1, [[-5,-4]], [[0, 1]])
        gcd1.shift(gcd1.get_edge_center(RIGHT)[0] * LEFT)
        gcd2 = mt(r", \ \gcd(r, a)=1").next_to(supposition, DOWN)
        setColor(gcd2, [[-4]], [[1]])

        gcd2.shift(gcd2.get_edge_center(LEFT)[0] * LEFT)

        self.play(Write(gcd1))
        self.play(Write(gcd2))

        neq = mt(r"\neq").move_to(poop_dimension[1])

        self.play(Write(neq))
        self.play(AnimationGroup(Unwrite(neq), Unwrite(gcd2), Unwrite(gcd1), lag_ratio=0.2))

        strike = Line((supposition.get_edge_center(LEFT)[0] - 0.3, supposition.get_edge_center(LEFT)[1], 0),
                      (supposition.get_edge_center(RIGHT)[0] + 0.3, supposition.get_edge_center(RIGHT)[1], 0))

        self.play(Create(strike))
        self.play(FadeOut(strike), FadeOut(supposition),
                  equation.animate.shift(UP))

        arr = mt(r"\downarrow").next_to(poop_dimension[1], DOWN)
        text_meow = Tex(r"All prime divisors of $h$ are divisors of $a$").next_to(arr, DOWN)
        setColor(text_meow, [[-15, -1]], [[0, 1]])

        self.play(Write(arr))
        self.play(Write(text_meow))

        self.hide_all()

        new_fact = MathTex(r"\text{If }b\geq2&\text{:}", r"\\ &p", "=",
                           r"\Phi_a(b^h)")
        setColor(new_fact, [[2], [], [], [1, 3, 4]], [[2],[], [], [1, 2, 0]])

        new_fact.to_edge(UP)

        conc_from_fact = Tex(r"All prime divisors of $h$ are divisors of $a$")
        setColor(conc_from_fact, [[-15, -1]], [[0, 1]])

        fact_arr = MathTex(r"\Downarrow", font_size=90)
        fact_arr.next_to(new_fact, DOWN)
        fact_arr.set_y(0.5 * (new_fact.get_edge_center(DOWN)[1] + conc_from_fact.get_edge_center(UP)[1]))

        new_fact[1:].shift([fact_arr.get_x() - new_fact[1:].get_x(), 0, 0])

        eqBox = SurroundingRectangle(new_fact, conc_from_fact, fact_arr, buff=0.1)

        self.play(Write(new_fact))
        self.play(Write(conc_from_fact), Write(fact_arr))
        self.play(Create(eqBox))

        self.hide_all()

        statements = [mt(r"p = b^{h} + 1", r"\Rightarrow", r"h = 2 ^\alpha"), mt(r"p = b^{2h}-b^h + 1", r"\Rightarrow", r"h = 2^\alpha3^\beta"), mt(r"p=b^{4h}-b^{3h}+b^{2h}-b^h+1", r"\Rightarrow", r"h=2^\alpha5^\beta")]
        setColor(statements[0], [[2, 3], [], [0]], [[2, 0], [], [0]])
        setColor(statements[1], [[2, 6, 4, 7], [], [0]], [[2, 2, 0, 0], [], [0]])
        setColor(statements[2], [[2, 6, 10, 14, 4, 8, 12, 15], [], [0]], [[2, 2, 2, 2, 0, 0, 0, 0], [], [0]])
        vdots = mt(r"\vdots")

        statements[1].move_to([0, 0, 0])
        statements[0].next_to(statements[1], UP, buff = 1)
        statements[2].next_to(statements[1], DOWN, buff = 1)

        for i in statements:
            i[0].to_edge(LEFT)
            i[1].set_x(0)
            i[2].to_edge(RIGHT)

        vdots.next_to(statements[2][1], DOWN, buff = 0.5)

        self.play(AnimationGroup(*[Write(statements[i]) for i in range(3)], Write(vdots), lag_ratio = 0.2))

    def construct(self):
        # play intro animation
        #self.intro()
        #play definitions animation
        #self.definitions()
        #play section 6
        self.the_result()
        self.step_27()
        self.last_section()
        #self.epilogue()